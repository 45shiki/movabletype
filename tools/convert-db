#!/usr/bin/perl -w

# Movable Type (r) (C) 2001-2016 Six Apart, Ltd. All Rights Reserved.
# This code cannot be redistributed without permission from www.sixapart.com.
# For more information, consult your Movable Type license.
#
# $Id$

use strict;

use Getopt::Long;
GetOptions(
    "old:s" => \my ($old_config),
    "new:s" => \my ($new_config)
);

use FindBin;
use lib ( "$FindBin::Bin/../lib", "$FindBin::Bin/../extlib" );
use File::Spec;
use MT;
use MT::Upgrade;

unless ($new_config) {
    print
        "Need configuration file location. cf: convert-db --new=mt-config.cgi.new\n";
    exit;
}

$old_config ||= '.';

my @TYPES;

eval {
    local $SIG{__WARN__} = sub { print "**** WARNING: $_[0]\n" };

    require MT;
    my $mt = MT->new( Config => $new_config ) or die MT->errstr;
    my $cfg = $mt->{cfg};

    my $cfg_file_new = $mt->{cfg_file};
    my $cfg_file_orig = $mt->find_config( { Config => $old_config } );
    print "convert source: $cfg_file_orig\n";
    print "   destination: $cfg_file_new\n";
    if ( $cfg_file_orig eq $cfg_file_new ) {
        print "Error: old config file and new config file is same.\n";
        print "       or, specified new-config file isn't exists.\n";
        exit;
    }
    print "Loading database schema...\n\n";
    my @TYPES = keys %{ MT->registry('object_types') };
    foreach my $type (@TYPES) {
        check_type($type);
    }

    $cfg->read_config($cfg_file_orig);

    require MT::ObjectDriverFactory;
    my $password   = $cfg->DBPassword;
    my $username   = $cfg->DBUser;
    my $dbd        = MT::ObjectDriverFactory->dbd_class;
    my $old_driver = MT::ObjectDriver::Driver::DBI->new(
        dbd       => $dbd,
        dsn       => $dbd->dsn_from_config($cfg),
        reuse_dbh => 1,
        ( $username ? ( username => $username ) : () ),
        ( $password ? ( password => $password ) : () ),
    );
    my $dbh = $old_driver->dbh_handle;

    $cfg->read_config($cfg_file_new);

    ## %ids will hold the highest IDs of each class.
    my %ids;
    my %TABLES;
    print "Loading data...\n";
    for my $type (@TYPES) {
        my $class = MT->model($type);
        print $class, "\n";

        my $table_name = $class->table_name();

        next if exists $TABLES{$table_name};
        $TABLES{$table_name} = 1;

        my $sth = $dbh->prepare("select * from $table_name;") or next;

        my $result_set;
        eval { $result_set = $sth->execute };
        next unless $result_set;

        my $datasource = $class->datasource;

        my %names;
        my %cat_parent;

        while ( my $row = $sth->fetchrow_hashref ) {
            my $obj = $class->new();

            my $values = {};
            while ( my ( $col, $value ) = each(%$row) ) {
                $col =~ s/${datasource}_//;
                $values->{$col} = $value;
            }
            $obj->set_values($values);
            printf "  %s\n", ( $obj->has_column('id') ? $obj->id : '.' );

            $obj = clean_object($obj);

            # Update IDs only auto_increment.
            $ids{$class} = $obj->id
                if $obj->column_defs->{id}->{auto}
                && ( !$ids{$class} || $obj->id > $ids{$class} );
            ## Look for duplicate template, category, and author names,
            ## because we have uniqueness constraints in the DB.
            if ( $class eq 'MT::Template' ) {
                my $key = $obj->blog_id . ':' . lc( $obj->name );
                if ( $names{$class}{$key}++ ) {
                    print "        Found duplicate template name '"
                        . $obj->name;
                    $obj->name( $obj->name . ' ' . $names{$class}{$key} );
                    print "'; renaming to '" . $obj->name . "'\n";
                }
                ## Touch the text column to make sure we read in
                ## any linked templates.
                my $text = $obj->text;
            }
            elsif ( $class eq 'MT::Author' ) {
                my $key = lc( $obj->name );
                if ( $names{ $class . $obj->type }{$key}++ ) {
                    print "        Found duplicate author name '"
                        . $obj->name;
                    $obj->name( $obj->name . ' ' . $names{$class}{$key} );
                    print "'; renaming to '" . $obj->name . "'\n";
                }
                $obj->email('')        unless defined $obj->email;
                $obj->set_password('') unless defined $obj->password;
            }
            elsif ( $class eq 'MT::Comment' ) {
                $obj->visible(1) unless defined $obj->visible;
            }
            elsif ( $class eq 'MT::TBPing' ) {
                $obj->visible(1) unless defined $obj->visible;
            }
            elsif ( $class eq 'MT::Category' ) {
                my $key = lc( $obj->label ) . $obj->blog_id;
                if ( $names{$class}{$key}++ ) {
                    print "        Found duplicate category label '"
                        . $obj->label;
                    $obj->label( $obj->label . ' ' . $names{$class}{$key} );
                    print "'; renaming to '" . $obj->label . "'\n";
                }

                # save the parent value for assignment at the end
                if ( $obj->parent ) {
                    $cat_parent{ $obj->id } = $obj->parent;
                    $obj->parent(0);
                }
            }
            elsif ( $class eq 'MT::Trackback' ) {
                $obj->entry_id(0)    unless defined $obj->entry_id;
                $obj->category_id(0) unless defined $obj->category_id;
            }
            elsif ( $class eq 'MT::Entry' ) {
                $obj->allow_pings(0)
                    if defined $obj->allow_pings && $obj->allow_pings eq '';
                $obj->allow_comments(0)
                    if defined $obj->allow_comments
                    && $obj->allow_comments eq '';
            }

            MT::Object::save($obj)
                or die "Fatal Error: Failed to save record for class $class: "
                . $obj->errstr;
        }

        # fix up the category parents
        foreach my $id ( keys %cat_parent ) {
            my $cat = MT::Category->load($id);
            $cat->parent( $cat_parent{$id} );
            $cat->save;
        }

        # for meta tables
        for my $which (qw( meta summary )) {
            if ( $class->meta_pkg($which) ) {
                my $class_meta = MT->model( $type . ":$which" );
                next unless $class_meta;
                my $datasource_meta = $class_meta->datasource;
                my $table_name_meta = $class_meta->table_name();

                my $sth = $dbh->prepare("select * from $table_name_meta;")
                    or next;
                my $result_set;
                eval { $result_set = $sth->execute };
                next unless $result_set;
                while ( my $row = $sth->fetchrow_hashref ) {
                    my $obj    = $class_meta->new();
                    my $values = {};
                    while ( my ( $col, $value ) = each(%$row) ) {
                        $col =~ s/${datasource_meta}_//;
                        $values->{$col} = $value;
                    }
                    $obj->set_values($values);
                    $obj->save()
                        or die
                        "Fatal Error: Failed to save record for class $class_meta: "
                        . $obj->errstr;
                }
            }
        }

        print "\n\n";
    }

    if ( $cfg->ObjectDriver =~ /postgres/ ) {
        print "Updating sequences\n";
        my $dbh = MT::Object->driver->{dbh};
        for my $class ( keys %ids ) {
            print "    $class => $ids{$class}\n";
            my $seq
                = 'mt_'
                . $class->datasource . '_'
                . $class->properties->{primary_key};
            $dbh->do("select setval('$seq', $ids{$class})")
                or die $dbh->errstr;
        }
    }
    elsif ( $cfg->ObjectDriver =~ /oracle/ ) {
        print "Updating sequences\n";
        for my $class ( keys %ids ) {
            print "    $class => $ids{$class}\n";
            MT::Object->driver->drop_sequence($class);
            MT::Object->driver->create_sequence($class);
        }
    }

    $cfg->SchemaVersion( MT->schema_version(), 1 );
    $cfg->save_config();
};
if ($@) {
    print "An error occurred while loading data: $@\n";
}
else {
    print "Done copying data! All went well.\n";
}

sub clean_object {
    my $obj  = shift;
    my $defs = $obj->column_defs;

    foreach my $col ( keys %{$defs} ) {
        my $def = $defs->{$col};
        next unless $def->{type};
        if ( $def->{type} =~ /(?:integer|smallint)/ && $obj->$col ) {
            my $val = $obj->$col;
            if ( $val =~ /\D/ ) {
                $val =~ s/\D//g;
                $obj->$col($val);
            }
        }
        if ( $def->{type} =~ /(?:string)/ && $obj->$col ) {
            require MT::I18N;
            my $val = $obj->$col;
            if ( MT::I18N::length_text($val) > $def->{size} ) {
                $obj->$col( MT::I18N::substr_text( $val, 0, $def->{size} ) );
            }
        }
    }
    return $obj;
}

sub check_type {
    my ($type) = @_;

    my $class = MT->model($type);

    if ( $class->meta_pkg ) {
        check_type( $type . ':meta' );
    }

    if ( my $result = MT::Upgrade->type_diff($type) ) {
        if ( $result->{fix} ) {
            MT::Upgrade->core_fix_type( type => $type );
        }
        else {
            MT::Upgrade->core_column_action( 'add', type => $type )
                if $result->{add};
            MT::Upgrade->core_column_action( 'alter', type => $type )
                if $result->{alter};
            MT::Upgrade->core_column_action( 'drop', type => $type )
                if $result->{drop};
            MT::Upgrade->core_column_action( 'index', type => $type )
                if $result->{index};
        }
    }
}

1;

__END__

=head1 NAME

convert-db - A tool to convert backend database of Movable Type

=head1 SYNOPSIS

convert-db --new=mt-config.cgi.new [--old=mt-config.cgi.current]

=head1 DESCRIPTION

I<convert-db> is a tool to convert database of Movable Type to 
others.  It is useful when it is necessary to switch like from 
MySQL to PostgreSQL.

The following options are available:

  --new       mt-config.cgi file of destination
  --old       mt-config.cgi file of source (optional)

It is also useful to replicate Movable Type database.

=cut
